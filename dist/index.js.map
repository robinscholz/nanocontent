{"version":3,"sources":["utils/file.js","lib/defaults.js","lib/readPage.js","lib/readPageSync.js","utils/page.js","lib/readFile.js","lib/readFileSync.js","lib/readFiles.js","lib/readSite.js","lib/readFilesSync.js","lib/readSiteSync.js","lib/index.js","index.js"],"names":["objectKeys","require","slash","assert","path","sortChildren","result","active","ext","extname","files","pages","push","filterFile","file","index","test","getFileType","extension","filetypes","reduce","value","i","source","indexOf","length","isFile","pathFile","equal","getFileMeta","opts","strictEqual","pathRoot","output","join","pathParent","name","basename","formatUrl","url","remove","prefix","toLowerCase","filename","type","replace","defaults","reservedKeys","ignore","encoding","asset","archive","audio","document","image","video","font","text","parser","pify","readPage","pathPage","fs","parse","fileIndex","pathUrl","content","getContent","readFile","err","children","getChildren","readdir","filter","getFiles","map","read","fileParsed","pathSource","getPages","pathSubpage","Object","assign","readPageSync","readFileSync","readdirSync","isPage","fileExtname","pathMeta","isAsync","Promise","resolve","fn","constructor","readFiles","pathSite","onFile","match","key","glob","readSite","readFilesSync","readSiteSync","sync","callback","lib","module","exports"],"mappings":"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","file":"index.js","sourceRoot":"../src","sourcesContent":["var objectKeys = require('object-keys')\nvar slash = require('normalize-path')\nvar assert = require('assert')\nvar path = require('path')\n\nexport { formatUrl, filterFile, getFileType, getFileMeta, sortChildren, isFile }\n\nfunction sortChildren(result, active) {\n  var ext = path.extname(active)\n  result = result || {}\n  result.files = result.files || []\n  result.pages = result.pages || []\n\n  if (ext) result.files.push(active)\n  else result.pages.push(active)\n\n  return result\n}\n\nfunction filterFile(file, index) {\n  if (file === '.DS_Store') return false\n  if (/(^[.#]|(?:__|~)$)/.test(file)) return false\n  if (path.extname(file) === path.extname(index)) return false\n  return true\n}\n\nfunction getFileType(extension, filetypes) {\n  return objectKeys(filetypes).reduce(function(result, value, i, source) {\n    if (result) return result\n\n    if (filetypes[value] && filetypes[value].indexOf(extension) >= 0) {\n      return value\n    }\n\n    if (i >= source.length) return 'unknown'\n  }, '')\n}\n\nfunction isFile(pathFile) {\n  assert.equal(typeof pathFile, 'string', 'pathFile must be type string')\n  return path.extname(pathFile) !== ''\n}\n\nfunction getFileMeta(opts) {\n  assert.strictEqual(typeof opts, 'object', 'opts must be type object')\n  assert.strictEqual(\n    typeof opts.pathFile,\n    'string',\n    'opts.pathFile must be type string'\n  )\n  assert.strictEqual(\n    typeof opts.pathRoot,\n    'string',\n    'opts.pathRoot must be type string'\n  )\n  assert.strictEqual(\n    typeof opts.filetypes,\n    'object',\n    'opts.filetypes must be type string'\n  )\n\n  var output = {}\n  var ext = path.extname(opts.pathFile)\n  var pathFile = slash(path.join(opts.pathParent || '', opts.pathFile))\n\n  output.name = path.basename(opts.pathFile, ext)\n  output.path = formatUrl(pathFile, opts.pathRoot)\n  output.url = formatUrl(pathFile, opts.pathRoot, opts.remove, opts.prefix)\n\n  if (ext) {\n    output.extension = ext.toLowerCase()\n    output.filename = path.basename(opts.pathFile)\n    output.type = getFileType(output.extension, opts.filetypes)\n  }\n\n  return output\n}\n\nfunction formatUrl(pathFile, pathRoot, remove, prefix) {\n  pathFile = pathFile.replace(pathRoot, '')\n  if (remove) pathFile = pathFile.replace(remove, '')\n  if (prefix) pathFile = prefix + pathFile\n  pathFile = slash(path.join('/', pathFile))\n  return pathFile || '/'\n}\n","const defaults = {\n  reservedKeys: ['files', 'pages', 'url', 'name', 'path'],\n  ignore: /(^[.#]|(?:__|~)$)/,\n  encoding: 'utf8',\n  file: 'index.md',\n  filetypes: {\n    asset: ['.css', '.js'],\n    archive: ['.zip'],\n    audio: ['.mp3', '.wav', '.aiff'],\n    document: ['.pdf'],\n    image: ['.gif', '.jpg', '.jpeg', '.png', '.svg'],\n    video: ['.mp4', '.webm', '.ogv', '.mov'],\n    font: ['.ttf', '.otf', '.woff', '.woff2'],\n    text: ['.txt', '.md'],\n  },\n}\n\nexport default defaults\n","import { formatUrl, filterFile, sortChildren, getFileMeta } from '../utils/file'\nimport defaults from './defaults'\n\nconst slash = require('normalize-path')\nconst assert = require('assert')\nconst parser = require('gray-matter')\nconst path = require('path')\nconst pify = require('pify')\n\nexport default readPage\n\nasync function readPage(pathPage, opts) {\n  assert.strictEqual(typeof pathPage, 'string', 'pathPage must be type string')\n  assert.strictEqual(typeof opts, 'object', 'opts must be type object')\n  assert.strictEqual(typeof opts.fs, 'object', 'opts.fs must be type object')\n\n  const fs = opts.fs.url ? opts.fs : pify(opts.fs) // web api or node\n  const parse = typeof opts.parse === 'function' ? opts.parse : parser\n  const fileIndex = opts.file || defaults.file\n  const pathRoot = opts.pathRoot || ''\n  const filetypes = opts.filetypes || defaults.filetypes\n  const pathUrl = formatUrl(pathPage, pathRoot, opts.remove)\n  const encoding = opts.encoding || defaults.encoding\n  const content = await getContent()\n  const childrenInput = await getChildren()\n  const children = childrenInput\n    .filter(file => filterFile(file, fileIndex))\n    .reduce(sortChildren, { files: [], pages: [] })\n  const files = await getFiles(children.files)\n  const pages = getPages(children.pages)\n\n  return Object.assign(content, {\n    name: path.basename(pathPage),\n    path: formatUrl(pathPage, pathRoot),\n    url: pathUrl,\n    files: files,\n    pages: pages,\n  })\n\n  async function getContent() {\n    try {\n      const content = await fs.readFile(\n        slash(path.join(pathPage, fileIndex)),\n        encoding\n      )\n      return parse(content)\n    } catch (err) {\n      return ''\n    }\n  }\n\n  async function getChildren() {\n    try {\n      return await fs.readdir(pathPage)\n    } catch (err) {\n      return []\n    }\n  }\n\n  async function getFiles(files) {\n    const result = {}\n    await files.map(read)\n    return result\n\n    async function read(pathFile) {\n      var fileParsed = getFileMeta({\n        pathFile: pathFile,\n        pathRoot: pathRoot,\n        filetypes: filetypes,\n        pathParent: pathPage,\n        pathSource: opts.source,\n        remove: opts.remove,\n        prefix: opts.prefix,\n      })\n\n      if (!filterFile(pathFile, fileIndex)) return false\n      else result[fileParsed.filename] = fileParsed.url\n    }\n  }\n\n  function getPages(pages) {\n    return pages.reduce(function(result, pathSubpage) {\n      const fileParsed = getFileMeta({\n        pathRoot: pathRoot,\n        pathFile: pathSubpage,\n        filetypes: filetypes,\n        pathParent: pathPage,\n        remove: opts.remove,\n        prefix: opts.prefix,\n      })\n\n      if (fileParsed.name) result[fileParsed.name] = fileParsed.url\n      return result\n    }, {})\n  }\n}\n","import { formatUrl, filterFile, sortChildren, getFileMeta } from '../utils/file'\nimport defaults from './defaults'\n\nconst slash = require('normalize-path')\nconst assert = require('assert')\nconst parser = require('gray-matter')\nconst path = require('path')\n\nexport default readPageSync\n\nfunction readPageSync(pathPage, opts) {\n  assert.strictEqual(typeof pathPage, 'string', 'pathPage must be type string')\n  assert.strictEqual(typeof opts, 'object', 'opts must be type object')\n  assert.strictEqual(typeof opts.fs, 'object', 'opts.fs must be type object')\n\n  const fs = opts.fs\n  const parse = typeof opts.parse === 'function' ? opts.parse : parser\n  const fileIndex = opts.file || defaults.file\n  const filetypes = opts.filetypes || defaults.filetypes\n  const pathRoot = opts.pathRoot || ''\n  const pathUrl = formatUrl(pathPage, pathRoot, opts.remove)\n  const encoding = opts.encoding || defaults.encoding\n  const content = getContent()\n  const children = getChildren()\n    .filter(file => filterFile(file, fileIndex))\n    .reduce(sortChildren, { files: [], pages: [] })\n  const files = getFiles(children.files)\n  const pages = getPages(children.pages)\n\n  return Object.assign(content, {\n    name: path.basename(pathPage),\n    path: formatUrl(pathPage, pathRoot),\n    url: pathUrl,\n    files: files,\n    pages: pages,\n  })\n\n  function getChildren() {\n    try {\n      return fs.readdirSync(pathPage)\n    } catch (err) {\n      return []\n    }\n  }\n\n  function getContent() {\n    try {\n      var content = fs.readFileSync(\n        slash(path.join(pathPage, fileIndex)),\n        encoding\n      )\n      return parse(content)\n    } catch (err) {\n      return ''\n    }\n  }\n\n  function getFiles(files) {\n    return files.reduce(function(result, pathFile) {\n      var fileParsed = getFileMeta({\n        pathFile: pathFile,\n        pathRoot: pathRoot,\n        filetypes: filetypes,\n        pathParent: pathPage,\n        remove: opts.remove,\n        prefix: opts.prefix,\n      })\n\n      if (!filterFile(pathFile, fileIndex)) return false\n      else result[fileParsed.filename] = fileParsed.url\n      return result\n    }, {})\n  }\n\n  function getPages(pages) {\n    return pages.reduce(function(result, pathSubpage) {\n      var fileParsed = getFileMeta({\n        pathRoot: pathRoot,\n        pathFile: pathSubpage,\n        filetypes: filetypes,\n        pathParent: pathPage,\n        pathSource: opts.source,\n        remove: opts.remove,\n        prefix: opts.prefix,\n      })\n\n      if (fileParsed.name) result[fileParsed.name] = fileParsed.url\n      return result\n    }, {})\n  }\n}\n","var assert = require('assert')\nvar path = require('path')\n\nexport { isPage }\n\nfunction isPage(pathPage) {\n  assert.strictEqual(typeof pathPage, 'string', 'pathPage must be type string')\n  return path.extname(pathPage) === ''\n}\n","import { getFileMeta } from '../utils/file'\nimport { isPage } from '../utils/page'\nimport defaults from './defaults'\nimport readPage from './readPage'\n\nconst pify = require('pify')\nconst assert = require('assert')\nconst parser = require('gray-matter')\nconst path = require('path')\n\nexport default readFile\n\nasync function readFile(pathFile, opts) {\n  assert.strictEqual(typeof pathFile, 'string', 'pathFile must be type string')\n  assert.strictEqual(typeof opts, 'object', 'opts must be type object')\n  assert.strictEqual(typeof opts.fs, 'object', 'opts.fs must be type object')\n\n  // pages\n  if (isPage(pathFile)) return readPage(pathFile, opts)\n\n  const fs = opts.fs\n  const parse = typeof opts.parse === 'function' ? opts.parse : parser\n  const fileIndex = opts.file || defaults.file\n  const fileExtname = path.extname(fileIndex).toLowerCase()\n  const filetypes = opts.filetypes || defaults.filetypes\n  const pathRoot = opts.pathRoot || ''\n  const encoding = opts.encoding || defaults.encoding\n  const fileParsed = getFileMeta({\n    pathFile: pathFile,\n    pathRoot: pathRoot,\n    filetypes: filetypes,\n    pathSource: opts.source,\n    remove: opts.remove,\n    prefix: opts.prefix,\n  })\n\n  // skip text files\n  if (fileExtname === fileParsed.extension) return false\n\n  try {\n    const pathMeta = pathFile + fileExtname\n    const text = isAsync(fs.readFile)\n      ? await fs.readFile(pathMeta, encoding)\n      : await pify(fs.readFile)(pathMeta, encoding)\n    return Object.assign(parse(text), fileParsed)\n  } catch (err) {\n    if (fileParsed.filename) return await fileParsed\n    else return Promise.resolve(false)\n  }\n}\n\nfunction isAsync(fn) {\n  return fn.constructor.name === 'AsyncFunction'\n}\n","import { getFileMeta } from '../utils/file'\nimport { isPage } from '../utils/page'\nimport defaults from './defaults'\nimport readPageSync from './readPageSync'\n\nconst assert = require('assert')\nconst parser = require('gray-matter')\nconst path = require('path')\n\nexport default readFileSync\n\nfunction readFileSync(pathFile, opts) {\n  assert.strictEqual(typeof pathFile, 'string', 'pathFile must be type string')\n  assert.strictEqual(typeof opts, 'object', 'opts must be type object')\n  assert.strictEqual(typeof opts.fs, 'object', 'opts.fs must be type object')\n\n  // page\n  if (isPage(pathFile)) return readPageSync(pathFile, opts)\n\n  const fs = opts.fs\n  const parse = typeof opts.parse === 'function' ? opts.parse : parser\n  const fileIndex = opts.file || defaults.file\n  const fileExtname = path.extname(fileIndex).toLowerCase()\n  const filetypes = opts.filetypes || defaults.filetypes\n  const pathRoot = opts.pathRoot || ''\n  const encoding = opts.encoding || defaults.encoding\n  const fileParsed = getFileMeta({\n    pathFile: pathFile,\n    pathRoot: pathRoot,\n    filetypes: filetypes,\n    remove: opts.remove,\n    prefix: opts.prefix,\n  })\n\n  // skip text files\n  if (fileExtname === fileParsed.extension) return false\n\n  try {\n    const pathMeta = pathFile + fileExtname\n    const text = fs.readFileSync(pathMeta, encoding)\n    return Object.assign(parse(text), fileParsed)\n  } catch (err) {\n    if (fileParsed.filename) return fileParsed\n    else return false\n  }\n}\n","import defaults from './defaults'\nimport readFile from './readFile'\n\nconst assert = require('assert')\n\nexport default readFiles\n\nasync function readFiles(files, pathSite, opts) {\n  assert.strictEqual(typeof files, 'object', 'files must be type object')\n  assert.strictEqual(typeof opts, 'object', 'opts must be type object')\n  assert.strictEqual(typeof opts.fs, 'object', 'opts.fs must be type object')\n\n  let output = {}\n\n  // read the index\n  if (files.indexOf(pathSite) < 0) {\n    files.push(pathSite)\n  }\n\n  // await files.map(read)\n  // return output\n\n  for (const pathFile of files) {\n    if (typeof opts.onFile === 'function') opts.onFile(pathFile)\n    let content = await readFile(pathFile, opts)\n    if (content && !content.name.match(defaults.ignore)) {\n      const key = content.url\n\n      // temp cleanup\n      content.url = content.extension ? content.path : content.url\n      delete content.path\n\n      output[key] = content\n    }\n  }\n\n  return output\n}\n","import readFiles from './readFiles'\n\nconst slash = require('normalize-path')\nconst assert = require('assert')\nconst path = require('path')\nconst pify = require('pify')\nconst glob = pify(require('glob'))\n\nexport default readSite\n\nasync function readSite(pathSite, opts) {\n  assert.strictEqual(typeof pathSite, 'string', 'pathSite must be type string')\n  assert.strictEqual(typeof opts, 'object', 'opts must be type object')\n  assert.strictEqual(typeof opts.fs, 'object', 'opts.fs must be type object')\n\n  // loop through the files\n  const files = await glob(slash(path.join(pathSite, '/**/*')))\n  return readFiles(files, pathSite, opts)\n}\n","import defaults from './defaults'\nimport readFileSync from './readFileSync'\n\nconst assert = require('assert')\n\nexport default readFilesSync\n\nfunction readFilesSync(files, pathSite, opts) {\n  assert.strictEqual(typeof files, 'object', 'files must be type object')\n  assert.strictEqual(typeof opts, 'object', 'opts must be type object')\n  assert.strictEqual(typeof opts.fs, 'object', 'opts.fs must be type object')\n\n  let output = {}\n\n  // read the index\n  if (files.indexOf(pathSite) < 0) {\n    files.push(pathSite)\n  }\n\n  for (const pathFile of files) {\n    if (typeof opts.onFile === 'function') opts.onFile(pathFile)\n    let content = readFileSync(pathFile, opts)\n    if (content && !content.name.match(defaults.ignore)) {\n      const key = content.url\n\n      // temp cleanup\n      content.url = content.extension ? content.path : content.url\n      delete content.path\n\n      output[key] = content\n    }\n  }\n\n  return output\n}\n","import readFilesSync from './readFilesSync'\n\nconst slash = require('normalize-path')\nconst assert = require('assert')\nconst path = require('path')\nconst glob = require('glob')\n\nexport default readSiteSync\n\nfunction readSiteSync(pathSite, opts) {\n  assert.strictEqual(typeof pathSite, 'string', 'pathSite must be type string')\n  assert.strictEqual(typeof opts, 'object', 'opts must be type object')\n  assert.strictEqual(typeof opts.fs, 'object', 'opts.fs must be type object')\n\n  // loop through the files\n  const files = glob.sync(slash(path.join(pathSite, '/**/*')))\n  return readFilesSync(files, pathSite, opts)\n}\n","import readPage from './readPage'\nimport readPageSync from './readPageSync'\nimport readFile from './readFile'\nimport readFileSync from './readFileSync'\nimport readFiles from './readFiles'\nimport readFilesSync from './readFiles'\nimport readSite from './readSite'\nimport readSiteSync from './readSiteSync'\n\nexport {\n  readPage,\n  readPageSync,\n  readFile,\n  readFileSync,\n  readFiles,\n  readFilesSync,\n  readSite,\n  readSiteSync,\n}\n","import * as lib from './lib/index.js'\n\nconst fs = require('fs-extra')\n\nmodule.exports = {\n  readFile: readFile,\n  readFileSync: readFileSync,\n  readFiles: readFiles,\n  readFilesSync: readFilesSync,\n  readPage: readPage,\n  readPageSync: readPageSync,\n  readSite: readSite,\n  readSiteSync: readSiteSync,\n}\n\nfunction readFile(pathFile, opts, callback) {\n  opts = Object.assign({ fs: fs }, opts || {})\n  return lib.readFile(pathFile, opts, callback)\n}\n\nfunction readFileSync(pathFile, opts) {\n  opts = Object.assign({ fs: fs }, opts || {})\n  return lib.readFileSync(pathFile, opts)\n}\n\nfunction readFiles(files, pathSite, opts, callback) {\n  opts = Object.assign({ fs: fs }, opts || {})\n  return lib.readFiles(files, pathSite, opts, callback)\n}\n\nfunction readFilesSync(pathFile, opts) {\n  opts = Object.assign({ fs: fs }, opts || {})\n  return lib.readFilesSync(pathFile, opts)\n}\n\nfunction readPage(pathPage, opts, callback) {\n  opts = Object.assign({ fs: fs }, opts || {})\n  return lib.readPage(pathPage, opts, callback)\n}\n\nfunction readPageSync(pathPage, opts) {\n  opts = Object.assign({ fs: fs }, opts || {})\n  return lib.readPageSync(pathPage, opts)\n}\n\nfunction readSite(pathSite, opts, callback) {\n  opts = Object.assign({ fs: fs }, opts || {})\n  return lib.readSite(pathSite, opts, callback)\n}\n\nfunction readSiteSync(pathSite, opts) {\n  opts = Object.assign({ fs: fs }, opts || {})\n  return lib.readSiteSync(pathSite, opts)\n}\n"]}